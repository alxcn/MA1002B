---
title: "S04: Control de Error y RK-F"
author: "Alejandro Ucan Puc"
date: "2022-11-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Recordando

En los métodos anteriores que estudiamos, utilizamos una aproximación a una EDO a un paso y dada por $$w_{i+1}=w_i+h_i\phi(t_i,w_i,h_i)$$ sin embargo en estos métodos descuidamos el error el cual puede crecer a medida que nos alejamos de las condiciones iniciales. 

Un método __ideal__ para aproximar estas soluciones tendría que considerar lo anterior $$w_{i+1}=w_i+h_i\phi(t_i,w_i,h_i)$$ y además convinar una tolerancia $$|y(t_i)-w_i|\leq \varepsilon$$ (una cota global del error) no importando si eso reduce el número de muestras que aproximemos, siempre y cuando tengamos la toleracia.

# Desarrollemos el algoritmo

## Algunas suposiciones

Supongamos que tenemos aproximaciones $w_i$ y $\tilde{w}_i$ que corresponden a métodos de orden 4 y 5, respectivamente, es decir, $$w_{i+1}=w_i+h\phi(t_i,w_i,h)+O(h^4)$$ $$\tilde{w}_{i+1}=\tilde{w}_i+h\psi(t_i,\tilde{w}_i,h)+O(h^5).$$ Denotaremos por $\tau_i(h)$ el error en el primer método y $\tilde{\tau}_i(h)$ en el segundo método. Esto es lo mismo que $$\tau_i(h)=\frac{y(t_i)-w_i}{h}$$ $$\tilde{\tau}_i(h)=\frac{y(t_i)-\tilde{w}_i}{h}.$$ Pero (con un poco de algebra) esto es equivalente a $$\tau_i(h)=\tilde{\tau}_i(h)+\frac{\tilde{w}_i-w_i}{h}$$